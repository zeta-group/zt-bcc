#!/usr/bin/php
<?php

/*

   Manipulates version of bcc.

*/

define( 'PROJECT_DIR', dirname( __DIR__ ) );
define( 'SRC_DIR', PROJECT_DIR . '/src' );
define( 'BUILD_DIR', PROJECT_DIR . '/build' );
define( 'VERSION_FILE', SRC_DIR . '/version.c' );
define( 'DEV_VERSION_FILE', BUILD_DIR . '/version.c' );
define( 'EXIT_SUCCESS', 0 );
define( 'EXIT_FAILURE', 1 );

class task {
   public $argv;
   public $script_path;
   public $command;
   public $major_number;
   public $minor_number;
   public $patch_number;
   // Total commits since the last release (public) version.
   public $count_number;

   public function __construct( $argv ) {
      $this->argv = $argv;
      $this->script_path = $argv[ 0 ];
      $this->command = '';
      $this->major_number = 0;
      $this->minor_number = 0;
      $this->patch_number = 0;
      $this->count_number = 0;
   }
}

function run( $argv ) {
   try {
      $task = new task( $argv );
      read_command( $task );
      execute_command( $task );
      exit( EXIT_SUCCESS );
   }
   catch ( Exception $e ) {
      exit( EXIT_FAILURE );
   }
}

function read_command( $task ) {
   $table = array(
      'help',
      'show',
      'bump-major',
      'bump-minor',
      'bump-patch',
      'dev',
      'start',
      'remove',
   );
   if ( count( $task->argv ) >= 2 ) {
      $command = strtolower( $task->argv[ 1 ] );
      if ( in_array( $command, $table ) ) {
         $task->command = $command;
      }
   }
}

function execute_command( $task ) {
   $table = array(
      'help' => 'handle_help',
      'show' => 'handle_show',
      'bump-major' => 'handle_bump_major',
      'bump-minor' => 'handle_bump_minor',
      'bump-patch' => 'handle_bump_patch',
      'dev' => 'handle_dev',
      'start' => 'handle_start',
      'remove' => 'handle_remove',
      '' => 'handle_empty',
   );
   if ( isset( $table[ $task->command ] ) ) {
      $table[ $task->command ]( $task );
   }
   else {
      show_err( "unhandled command: " . $task->command );
      bail();
   }
}

function handle_help( $task ) {
   show_help( $task );
}

function show_help( $task ) {
   printf(
      "Usage: %s [command]\n" .
      "Commands:\n" .
      "  help        Show this help information\n" .
      "  show        Show current version\n" .
      "  bump-major  Bump major number of version\n" .
      "  bump-minor  Bump minor number of version\n" .
      "  bump-patch  Bump patch number of version\n" .
      "  dev         Update development version\n" .
      "  start       Set to initial version\n" .
      "  remove      Remove development version file\n" .
      "",
      $task->script_path );
}

function handle_show( $task ) {
   load_version( $task );
   printf( "%s\n", encode_version( $task ) );
}

function git( $task, $args ) {
   $code = 1;
   $output = array();
   $command = sprintf( 'git --no-pager %s', $args );
   exec( $command, $output, $code );
   if ( $code != 0 ) {
      show_err( $task, 'failed to execute git command' );
      bail();
   }
   return $output;
}

function load_version( $task ) {
   $output = git( $task, 'log -n 1 --pretty="%H%n%s" ' .
      '-E --grep="^Declare version: [0-9.]+$"' );
   if ( count( $output ) == 2 ) {
      list( $hash, $subject ) = $output;
      $matches = array();
      $result = preg_match( '/^.+: (.+)$/', $subject, $matches );
      if ( $result === 1 ) {
         $encoded_version = $matches[ 1 ];
         decode_version( $task, $encoded_version );
      }
      // Number of commits since last public release.
      $output = git( $task, 'rev-list --count ' . $hash . '..HEAD' );
      if ( count( $output ) == 1 ) {
         $task->count_number = ( int ) $output[ 0 ];
      }
   }
}

function save_version( $task ) {
   $version = encode_version( $task );
   write_version_file( $task, VERSION_FILE, $version );
   commit( $task, $version );
}

function write_version_file( $task, $path, $version ) {
   $written = @file_put_contents( $path,
      create_version_file_content( $version ) );
   if ( $written === false ) {
      show_err( $task );
      bail();
   }
}

function create_version_file_content( $version ) {
   return sprintf(
      "// NOTE: This file is automatically generated.\n" .
      "const char* c_version = \"%s\";\n", $version );
}

function encode_version( $task ) {
   $version = sprintf( '%d.%d.%d',
      $task->major_number,
      $task->minor_number,
      $task->patch_number );
   if ( is_development_version( $task ) ) {
      $version = sprintf( '%s.%s', $version, $task->count_number );
   }
   return $version;
}

function decode_version( $task, $version ) {
   $matches = array();
   $result = preg_match(
      '/^([0-9]+)\.([0-9]+)\.([0-9]+)$/',
      $version, $matches );
   if ( $result !== 1 ) {
      show_err( $task, "version string of incorrect format" );
      bail();
   }
   $task->major_number = ( int ) $matches[ 1 ];
   $task->minor_number = ( int ) $matches[ 2 ];
   $task->patch_number = ( int ) $matches[ 3 ];
}

function create_commit_message( $version ) {
   return sprintf( 'Declare version: %s', $version );
}

function is_development_version( $task ) {
   return ( $task->count_number > 0 );
}

function get_latest_commit_hash( $task ) {
   $code = 1;
   $lines = array();
   exec( 'git --no-pager log -n 1 --pretty="%H"', $lines, $code );
   if ( ! ( $code == 0 && count( $lines ) == 1 ) ) {
      show_err( $task, 'failed to get hash of latest commit' );
      bail();
   }
   return $lines[ 0 ];
}

function commit( $task, $version ) {
   $command = sprintf( 'commit -m "%s" %s', create_commit_message( $version ),
      VERSION_FILE );
   git( $task, $command );
}

function handle_bump_major( $task ) {
   load_version( $task );
   ++$task->major_number;
   $task->minor_number = 0;
   $task->patch_number = 0;
   $task->count_number = 0;
   save_version( $task );
}

function handle_bump_minor( $task ) {
   load_version( $task );
   ++$task->minor_number;
   $task->patch_number = 0;
   $task->count_number = 0;
   save_version( $task );
}

function handle_bump_patch( $task ) {
   load_version( $task );
   ++$task->patch_number;
   $task->count_number = 0;
   save_version( $task );
}

function handle_dev( $task ) {
   load_version( $task );
   $version = encode_version( $task );
   if ( ! is_latest_development_version( $task, $version ) ) {
      write_version_file( $task, DEV_VERSION_FILE, $version );
   }
}

function is_latest_development_version( $task, $version ) {
   if ( file_exists( DEV_VERSION_FILE ) ) {
      $old_content = @file_get_contents( DEV_VERSION_FILE );
      $new_content = create_version_file_content( $version );
      if ( $old_content === $new_content ) {
         return true;
      }
   }
   return false;
}

function handle_start( $task ) {
   save_version( $task );
}

function handle_remove( $task ) {
   if ( file_exists( DEV_VERSION_FILE ) ) {
      unlink( DEV_VERSION_FILE );
   }
}

function handle_empty( $task ) {
   show_help( $task );
   bail();
}

function show_err( $task, $msg = '' ) {
   $prefix = sprintf( '%s', basename( $task->script_path ) );
   if ( $msg == '' ) {
      $err = error_get_last();
      if ( $err !== null ) {
         $prefix = sprintf( '%s:%d', $prefix, $err[ 'line' ] );
         $msg = $err[ 'message' ];
      }
   }
   printf( "%s: error: %s\n", $prefix, $msg );
}

function bail() {
   throw new Exception();
}

run( $argv );
